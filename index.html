<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoPredict Pro - AI-Powered Crypto Predictions</title>
    <style>
        :root {
            --primary: #6e3bff;
            --secondary: #00d4ff;
            --dark: #1a1a2e;
            --light: #f5f5f5;
            --success: #28a745;
            --danger: #dc3545;
            --warning: #fd7e14;
            --info: #17a2b8;
            --premium: #ffc107;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, var(--dark), #16213e);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .premium-banner {
            position: absolute;
            top: 0;
            right: -50px;
            background: var(--premium);
            color: #000;
            padding: 5px 50px;
            transform: rotate(45deg);
            font-weight: bold;
            font-size: 0.8rem;
            transform-origin: left;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            position: relative;
            display: inline-block;
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.8;
        }
        
        .dashboard {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }
        
        .sidebar {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: fit-content;
        }
        
        .search-box {
            margin-bottom: 20px;
            position: relative;
        }
        
        .search-box input {
            width: 100%;
            padding: 12px 15px;
            border-radius: 8px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
        }
        
        .search-box input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        
        .search-icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.5;
        }
        
        .coin-list {
            max-height: 500px;
            overflow-y: auto;
        }
        
        .coin-item {
            display: flex;
            align-items: center;
            padding: 12px 10px;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .coin-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .coin-item.active {
            background: linear-gradient(to right, var(--primary), var(--secondary));
        }
        
        .coin-item.premium::after {
            content: "PRO";
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--premium);
            color: #000;
            font-size: 0.7rem;
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        .coin-icon {
            width: 30px;
            height: 30px;
            margin-right: 10px;
            border-radius: 50%;
        }
        
        .coin-name {
            font-weight: 600;
            flex-grow: 1;
        }
        
        .coin-symbol {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
        }
        
        .main-content {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-height: 80vh;
        }
        
        .coin-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .coin-title {
            display: flex;
            align-items: center;
        }
        
        .large-coin-icon {
            width: 50px;
            height: 50px;
            margin-right: 15px;
            border-radius: 50%;
        }
        
        .coin-title-text h2 {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }
        
        .coin-title-text span {
            opacity: 0.7;
            font-size: 1rem;
        }
        
        .price-display {
            margin-left: auto;
            text-align: right;
        }
        
        .current-price {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .price-change {
            font-size: 1rem;
            padding: 3px 10px;
            border-radius: 5px;
        }
        
        .positive {
            background-color: rgba(40, 167, 69, 0.2);
            color: var(--success);
        }
        
        .negative {
            background-color: rgba(220, 53, 69, 0.2);
            color: var(--danger);
        }
        
        .neutral {
            background-color: rgba(253, 126, 20, 0.2);
            color: var(--warning);
        }
        
        .info {
            background-color: rgba(23, 162, 184, 0.2);
            color: var(--info);
        }
        
        .premium-feature {
            background-color: rgba(255, 193, 7, 0.2);
            color: var(--premium);
            border-left: 3px solid var(--premium);
            padding-left: 10px;
        }
        
        .time-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .time-btn {
            padding: 8px 15px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .time-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .time-btn.active {
            background: linear-gradient(to right, var(--primary), var(--secondary));
        }
        
        .chart-container {
            height: 400px;
            margin-bottom: 30px;
            position: relative;
        }
        
        canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        .prediction-section {
            margin-top: 30px;
        }
        
        .prediction-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .prediction-header h3 {
            font-size: 1.5rem;
            margin-right: 15px;
        }
        
        .prediction-period {
            padding: 5px 10px;
            border-radius: 5px;
            background: rgba(110, 59, 255, 0.2);
            color: var(--primary);
            font-size: 0.9rem;
        }
        
        .prediction-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }
        
        .prediction-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        
        .prediction-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .prediction-date {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-bottom: 10px;
        }
        
        .prediction-price {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .prediction-change {
            font-size: 0.9rem;
            padding: 3px 10px;
            border-radius: 5px;
            display: inline-block;
        }
        
        .prediction-confidence {
            margin-top: 15px;
            font-size: 0.9rem;
        }
        
        .confidence-bar {
            height: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden;
        }
        
        .confidence-level {
            height: 100%;
            border-radius: 5px;
            background: linear-gradient(to right, var(--primary), var(--secondary));
        }
        
        .loader {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            min-height: 300px;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .accuracy-badge {
            background: rgba(0, 212, 255, 0.2);
            color: var(--secondary);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            display: inline-flex;
            align-items: center;
        }
        
        .accuracy-badge i {
            margin-right: 5px;
        }
        
        .error-message {
            background: rgba(220, 53, 69, 0.2);
            color: var(--danger);
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }
        
        .retry-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            margin-top: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .retry-btn:hover {
            background: var(--secondary);
        }
        
        .skeleton-loader {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        .suggestions-section {
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .suggestions-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .suggestions-header h3 {
            font-size: 1.5rem;
            margin-right: 15px;
        }
        
        .suggestion-card {
            display: flex;
            align-items: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .suggestion-card:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .suggestion-icon {
            width: 40px;
            height: 40px;
            margin-right: 15px;
            border-radius: 50%;
        }
        
        .suggestion-details {
            flex-grow: 1;
        }
        
        .suggestion-name {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .suggestion-reason {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .suggestion-action {
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .buy {
            background-color: rgba(40, 167, 69, 0.2);
            color: var(--success);
        }
        
        .hold {
            background-color: rgba(253, 126, 20, 0.2);
            color: var(--warning);
        }
        
        .sell {
            background-color: rgba(220, 53, 69, 0.2);
            color: var(--danger);
        }
        
        .premium-lock {
            position: absolute;
            top: 10px;
            right: 10px;
            color: var(--premium);
            font-size: 0.8rem;
            display: flex;
            align-items: center;
        }
        
        .premium-lock i {
            margin-right: 5px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
        }
        
        .metric-title {
            font-size: 0.9rem;
            opacity: 0.7;
            margin-bottom: 10px;
        }
        
        .metric-value {
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .metric-change {
            font-size: 0.8rem;
            margin-top: 5px;
        }
        
        .premium-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .premium-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .premium-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .close-modal {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .premium-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(to right, var(--premium), #ff8c00);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .premium-features {
            margin-bottom: 30px;
        }
        
        .premium-feature-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .premium-feature-item i {
            margin-right: 15px;
            color: var(--premium);
            font-size: 1.2rem;
        }
        
        .premium-plans {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .premium-plan {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .premium-plan:hover {
            transform: translateY(-5px);
            border-color: var(--premium);
        }
        
        .premium-plan.recommended {
            border: 1px solid var(--premium);
            position: relative;
        }
        
        .recommended-badge {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--premium);
            color: #000;
            padding: 3px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .plan-name {
            font-size: 1.2rem;
            margin-bottom: 10px;
        }
        
        .plan-price {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 10px;
            color: var(--premium);
        }
        
        .plan-period {
            opacity: 0.7;
            margin-bottom: 15px;
        }
        
        .subscribe-btn {
            background: var(--premium);
            color: #000;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s ease;
        }
        
        .subscribe-btn:hover {
            background: #ffd700;
            transform: translateY(-2px);
        }
        
        .premium-trial {
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .premium-trial a {
            color: var(--premium);
            text-decoration: none;
        }
        
        .technical-indicators {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .indicator-btn {
            padding: 5px 10px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
            border: none;
            color: white;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .indicator-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .indicator-btn.active {
            background: linear-gradient(to right, var(--primary), var(--secondary));
        }
        
        .premium-tag {
            background: rgba(255, 193, 7, 0.2);
            color: var(--premium);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.7rem;
            margin-left: 5px;
            vertical-align: middle;
        }
        
        /* New styles for added features */
        .assistant-button {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 999;
            transition: all 0.3s ease;
        }
        
        .assistant-button:hover {
            transform: scale(1.1);
        }
        
        .assistant-modal {
            position: fixed;
            bottom: 100px;
            right: 30px;
            width: 350px;
            max-height: 500px;
            background: rgba(26, 26, 46, 0.95);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .assistant-modal.active {
            display: flex;
        }
        
        .assistant-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .assistant-header h3 {
            font-size: 1.2rem;
            margin-left: 10px;
        }
        
        .assistant-messages {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 15px;
            padding-right: 10px;
        }
        
        .assistant-message {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 10px;
            max-width: 80%;
        }
        
        .assistant-message.user {
            background: rgba(110, 59, 255, 0.2);
            margin-left: auto;
            border-bottom-right-radius: 0;
        }
        
        .assistant-message.bot {
            background: rgba(255, 255, 255, 0.1);
            margin-right: auto;
            border-bottom-left-radius: 0;
        }
        
        .assistant-input {
            display: flex;
            gap: 10px;
        }
        
        .assistant-input input {
            flex-grow: 1;
            padding: 10px 15px;
            border-radius: 20px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .assistant-input button {
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 20px;
            padding: 0 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .assistant-input button:hover {
            background: var(--secondary);
        }
        
        .voice-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
            margin-left: 5px;
        }
        
        .gamification-badge {
            display: inline-flex;
            align-items: center;
            background: rgba(110, 59, 255, 0.2);
            color: var(--primary);
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            margin-left: 10px;
        }
        
        .gamification-badge i {
            margin-right: 5px;
        }
        
        .weather-report {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .weather-icon {
            font-size: 2rem;
            margin-right: 15px;
        }
        
        .weather-details {
            flex-grow: 1;
        }
        
        .weather-title {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .weather-description {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .reality-check {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border-left: 3px solid var(--warning);
        }
        
        .reality-check h4 {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .reality-check h4 i {
            margin-right: 10px;
            color: var(--warning);
        }
        
        .tarot-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .tarot-card h4 {
            margin-bottom: 10px;
            color: var(--premium);
        }
        
        .tarot-image {
            width: 100px;
            height: 150px;
            background: linear-gradient(135deg, #6e3bff, #00d4ff);
            margin: 0 auto 10px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }
        
        .tarot-meaning {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        .bingo-card {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
            margin-bottom: 20px;
        }
        
        .bingo-square {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 0.7rem;
            padding: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .bingo-square:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .bingo-square.marked {
            background: rgba(110, 59, 255, 0.3);
            position: relative;
        }
        
        .bingo-square.marked::after {
            content: "✓";
            position: absolute;
            top: 2px;
            right: 2px;
            color: var(--success);
            font-weight: bold;
        }
        
        .bingo-center {
            background: rgba(255, 193, 7, 0.2);
        }
        
        .bingo-progress {
            height: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin-bottom: 10px;
            overflow: hidden;
        }
        
        .bingo-progress-bar {
            height: 100%;
            background: linear-gradient(to right, var(--primary), var(--secondary));
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .meme-analysis {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .meme-analysis h4 {
            margin-bottom: 10px;
            color: var(--info);
        }
        
        .meme-score {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .meme-score-bar {
            flex-grow: 1;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin: 0 10px;
            overflow: hidden;
        }
        
        .meme-score-fill {
            height: 100%;
            background: linear-gradient(to right, var(--primary), var(--secondary));
        }
        
        .meme-score-value {
            font-weight: bold;
            min-width: 30px;
            text-align: right;
        }
        
        .meme-impact {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 0.3; }
        }
        
        @media (max-width: 992px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .coin-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .price-display {
                margin-left: 0;
                margin-top: 15px;
                text-align: left;
            }
            
            .premium-plans {
                grid-template-columns: 1fr;
            }
            
            .metrics-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
            
            .assistant-modal {
                width: calc(100% - 40px);
                right: 20px;
                bottom: 80px;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <div class="premium-banner">PREMIUM</div>
            <h1>CryptoPredict Pro</h1>
            <p class="subtitle">AI-powered cryptocurrency predictions with 95% accuracy</p>
        </header>
        
        <div class="dashboard">
            <div class="sidebar">
                <div class="search-box">
                    <input type="text" placeholder="Search cryptocurrencies..." id="searchInput">
                    <span class="search-icon">🔍</span>
                </div>
                <div class="coin-list" id="coinList">
                    <!-- Skeleton loading for coin list -->
                    <div class="skeleton-loader" style="height: 60px; margin-bottom: 8px;"></div>
                    <div class="skeleton-loader" style="height: 60px; margin-bottom: 8px;"></div>
                    <div class="skeleton-loader" style="height: 60px; margin-bottom: 8px;"></div>
                    <div class="skeleton-loader" style="height: 60px; margin-bottom: 8px;"></div>
                    <div class="skeleton-loader" style="height: 60px; margin-bottom: 8px;"></div>
                </div>
            </div>
            
            <div class="main-content">
                <div id="coinDetail">
                    <!-- Daily Suggestions Section -->
                    <div class="suggestions-section" id="suggestionsSection">
                        <div class="suggestions-header">
                            <h3><i class="fas fa-robot"></i> Today's AI Suggestions</h3>
                            <div class="accuracy-badge">
                                <i class="fas fa-bolt"></i> 95% Accuracy
                            </div>
                            <div class="gamification-badge">
                                <i class="fas fa-trophy"></i> Top 5% Analyst
                            </div>
                        </div>
                        <div id="suggestionsList">
                            <div class="skeleton-loader" style="height: 80px; margin-bottom: 10px;"></div>
                            <div class="skeleton-loader" style="height: 80px; margin-bottom: 10px;"></div>
                            <div class="skeleton-loader" style="height: 80px;"></div>
                        </div>
                    </div>
                    
                    <!-- Crypto Weather Report -->
                    <div class="weather-report">
                        <div class="weather-icon">
                            <i class="fas fa-cloud-sun"></i>
                        </div>
                        <div class="weather-details">
                            <div class="weather-title">Crypto Weather Report</div>
                            <div class="weather-description" id="weatherDescription">Loading market climate...</div>
                        </div>
                    </div>
                    
                    <!-- Reality Check Section -->
                    <div class="reality-check">
                        <h4><i class="fas fa-brain"></i> AI Reality Check</h4>
                        <div id="realityCheckText">Analyzing your recent predictions for cognitive biases...</div>
                    </div>
                    
                    <!-- Crypto Tarot Card -->
                    <div class="tarot-card">
                        <h4><i class="fas fa-magic"></i> Crypto Tarot</h4>
                        <div class="tarot-image" id="tarotImage">
                            <i class="fas fa-question"></i>
                        </div>
                        <div class="tarot-meaning" id="tarotMeaning">Drawing your daily crypto fortune...</div>
                    </div>
                    
                    <!-- Meme Analysis -->
                    <div class="meme-analysis">
                        <h4><i class="fas fa-grin-squint-tears"></i> Meme Impact Analysis</h4>
                        <div class="meme-score">
                            <span>Sentiment:</span>
                            <div class="meme-score-bar">
                                <div class="meme-score-fill" id="memeScoreFill" style="width: 0%"></div>
                            </div>
                            <div class="meme-score-value" id="memeScoreValue">0%</div>
                        </div>
                        <div class="meme-impact" id="memeImpact">Analyzing latest meme trends...</div>
                    </div>
                    
                    <!-- Prediction Bingo -->
                    <div class="bingo-card-container">
                        <h4><i class="fas fa-th-large"></i> Prediction Bingo</h4>
                        <div class="bingo-progress">
                            <div class="bingo-progress-bar" id="bingoProgressBar" style="width: 0%"></div>
                        </div>
                        <div class="bingo-card" id="bingoCard">
                            <!-- Filled by JavaScript -->
                        </div>
                    </div>
                    
                    <!-- Coin Details Section -->
                    <div class="skeleton-loader" style="height: 80px; margin-bottom: 20px;"></div>
                    <div class="skeleton-loader" style="height: 40px; margin-bottom: 20px; width: 80%;"></div>
                    <div class="skeleton-loader" style="height: 400px; margin-bottom: 30px;"></div>
                    <div class="skeleton-loader" style="height: 40px; margin-bottom: 20px; width: 60%;"></div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px;">
                        <div class="skeleton-loader" style="height: 150px;"></div>
                        <div class="skeleton-loader" style="height: 150px;"></div>
                        <div class="skeleton-loader" style="height: 150px;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- AI Assistant Button -->
    <div class="assistant-button" id="assistantButton">
        <i class="fas fa-robot"></i>
    </div>
    
    <!-- AI Assistant Modal -->
    <div class="assistant-modal" id="assistantModal">
        <div class="assistant-header">
            <i class="fas fa-robot"></i>
            <h3>CryptoPredict Assistant</h3>
        </div>
        <div class="assistant-messages" id="assistantMessages">
            <div class="assistant-message bot">
                Hello! I'm your AI assistant. How can I help you with crypto predictions today?
            </div>
        </div>
        <div class="assistant-input">
            <input type="text" placeholder="Ask me anything about crypto..." id="assistantInput">
            <button id="sendMessage"><i class="fas fa-paper-plane"></i></button>
            <button class="voice-btn" id="voiceButton"><i class="fas fa-microphone"></i></button>
        </div>
    </div>

    <!-- Premium Modal -->
    <div class="premium-modal" id="premiumModal">
        <div class="premium-content">
            <button class="close-modal" id="closeModal">&times;</button>
            <h2 class="premium-title">Upgrade to CryptoPredict Pro</h2>
            
            <div class="premium-features">
                <h3>Premium Features:</h3>
                <div class="premium-feature-item">
                    <i class="fas fa-chart-line"></i>
                    <div>
                        <strong>Advanced Predictions</strong> - Get hyper-accurate predictions using 15+ technical indicators
                    </div>
                </div>
                <div class="premium-feature-item">
                    <i class="fas fa-bell"></i>
                    <div>
                        <strong>Real-time Alerts</strong> - Instant notifications for price movements and buy/sell signals
                    </div>
                </div>
                <div class="premium-feature-item">
                    <i class="fas fa-robot"></i>
                    <div>
                        <strong>AI Portfolio Builder</strong> - Automated portfolio optimization based on your risk profile
                    </div>
                </div>
                <div class="premium-feature-item">
                    <i class="fas fa-whale"></i>
                    <div>
                        <strong>Whale Activity Tracking</strong> - See where big money is flowing in real-time
                    </div>
                </div>
                <div class="premium-feature-item">
                    <i class="fas fa-lock-open"></i>
                    <div>
                        <strong>All Cryptocurrencies</strong> - Access predictions for all 5000+ coins, not just top 100
                    </div>
                </div>
                <div class="premium-feature-item">
                    <i class="fas fa-calendar-alt"></i>
                    <div>
                        <strong>Long-term Forecasts</strong> - Get 1-year predictions with 90%+ confidence
                    </div>
                </div>
                <div class="premium-feature-item">
                    <i class="fas fa-vr-cardboard"></i>
                    <div>
                        <strong>AR/VR Features</strong> - 3D visualizations and augmented reality charting
                    </div>
                </div>
                <div class="premium-feature-item">
                    <i class="fas fa-brain"></i>
                    <div>
                        <strong>Emotional Analysis</strong> - Biometric feedback and mood detection for better decisions
                    </div>
                </div>
            </div>
            
            <div class="premium-plans">
                <div class="premium-plan">
                    <div class="plan-name">Monthly</div>
                    <div class="plan-price">$29</div>
                    <div class="plan-period">per month</div>
                    <button class="subscribe-btn">Subscribe Now</button>
                </div>
                <div class="premium-plan recommended">
                    <div class="recommended-badge">Best Value</div>
                    <div class="plan-name">Yearly</div>
                    <div class="plan-price">$249</div>
                    <div class="plan-period">per year (save 30%)</div>
                    <button class="subscribe-btn">Subscribe Now</button>
                </div>
            </div>
            
            <div class="premium-trial">
                <p>Not ready to commit? Try our <a href="#">7-day free trial</a> with all premium features.</p>
            </div>
        </div>
    </div>

    <!-- Include Chart.js for price charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Include Moment.js for date handling -->
    <script src="https://cdn.jsdelivr.net/npm/moment"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment"></script>
    <!-- Include technical indicators library -->
    <script src="https://cdn.jsdelivr.net/npm/technicalindicators/dist/technicalindicators.min.js"></script>
    
    <script>
        // Global variables
        let allCoins = [];
        let currentCoin = null;
        let priceChart = null;
        let currentTimeRange = '7d';
        let activeIndicators = ['ema', 'macd', 'rsi'];
        let isPremiumUser = false;
        let apiRetryCount = 0;
        const maxRetries = 3;
        let bingoCard = [];
        let markedBingoSquares = [];
        let assistantActive = false;
        
        // DOM elements
        const coinListElement = document.getElementById('coinList');
        const coinDetailElement = document.getElementById('coinDetail');
        const searchInput = document.getElementById('searchInput');
        const suggestionsSection = document.getElementById('suggestionsSection');
        const suggestionsList = document.getElementById('suggestionsList');
        const premiumModal = document.getElementById('premiumModal');
        const closeModal = document.getElementById('closeModal');
        const assistantButton = document.getElementById('assistantButton');
        const assistantModal = document.getElementById('assistantModal');
        const assistantMessages = document.getElementById('assistantMessages');
        const assistantInput = document.getElementById('assistantInput');
        const sendMessageButton = document.getElementById('sendMessage');
        const voiceButton = document.getElementById('voiceButton');
        const weatherDescription = document.getElementById('weatherDescription');
        const realityCheckText = document.getElementById('realityCheckText');
        const tarotImage = document.getElementById('tarotImage');
        const tarotMeaning = document.getElementById('tarotMeaning');
        const memeScoreFill = document.getElementById('memeScoreFill');
        const memeScoreValue = document.getElementById('memeScoreValue');
        const memeImpact = document.getElementById('memeImpact');
        const bingoCardElement = document.getElementById('bingoCard');
        const bingoProgressBar = document.getElementById('bingoProgressBar');
        
        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            console.log("Initializing app...");
            fetchTopCryptocurrencies();
            
            // Setup search functionality with debounce
            let searchTimeout;
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    const searchTerm = e.target.value.toLowerCase();
                    const filteredCoins = allCoins.filter(coin => 
                        coin.name.toLowerCase().includes(searchTerm) || 
                        coin.symbol.toLowerCase().includes(searchTerm)
                    );
                    displayCoinList(filteredCoins);
                }, 300);
            });
            
            // Premium modal handlers
            closeModal.addEventListener('click', () => {
                premiumModal.classList.remove('active');
            });
            
            // Close modal when clicking outside
            premiumModal.addEventListener('click', (e) => {
                if (e.target === premiumModal) {
                    premiumModal.classList.remove('active');
                }
            });
            
            // AI Assistant handlers
            assistantButton.addEventListener('click', toggleAssistant);
            sendMessageButton.addEventListener('click', sendAssistantMessage);
            assistantInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendAssistantMessage();
                }
            });
            voiceButton.addEventListener('click', toggleVoiceRecognition);
            
            // Initialize gamification features
            initializeBingoCard();
            generateCryptoWeather();
            generateRealityCheck();
            drawTarotCard();
            analyzeMemeImpact();
        });

        // Enhanced fetch function with retry logic
        async function fetchWithRetry(url, options = {}, retries = 3) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return response;
            } catch (error) {
                if (retries > 0) {
                    console.log(`Retrying... ${retries} attempts left`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return fetchWithRetry(url, options, retries - 1);
                } else {
                    throw new Error(`Failed to fetch after ${maxRetries} attempts: ${error.message}`);
                }
            }
        }

        // Format date properly for display
        function formatDisplayDate(date) {
            const options = { month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Format date for tooltips
        function formatTooltipDate(date) {
            const options = { month: 'short', day: 'numeric', year: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Calculate EMA (Exponential Moving Average)
        function calculateEMA(prices, period) {
            const emaValues = [];
            const k = 2 / (period + 1);
            let ema = prices[0];
            
            for (let i = 0; i < prices.length; i++) {
                ema = prices[i] * k + ema * (1 - k);
                emaValues.push(ema);
            }
            
            return emaValues;
        }

        // Calculate VWMA (Volume Weighted Moving Average)
        function calculateVWMA(prices, volumes, period) {
            const vwmaValues = [];
            
            for (let i = period - 1; i < prices.length; i++) {
                let sumPV = 0;
                let sumV = 0;
                
                for (let j = 0; j < period; j++) {
                    sumPV += prices[i - j] * volumes[i - j];
                    sumV += volumes[i - j];
                }
                
                vwmaValues.push(sumPV / sumV);
            }
            
            // Pad with nulls for the initial period
            return Array(period - 1).fill(null).concat(vwmaValues);
        }

        // Calculate RSI (Relative Strength Index)
        function calculateRSI(prices, period = 14) {
            const rsiValues = [];
            let gains = 0;
            let losses = 0;
            
            // Calculate initial average gains and losses
            for (let i = 1; i <= period; i++) {
                const change = prices[i] - prices[i - 1];
                if (change >= 0) {
                    gains += change;
                } else {
                    losses += Math.abs(change);
                }
            }
            
            let avgGain = gains / period;
            let avgLoss = losses / period;
            let rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            rsiValues.push(100 - (100 / (1 + rs)));
            
            // Calculate subsequent RSI values
            for (let i = period + 1; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                let currentGain = 0;
                let currentLoss = 0;
                
                if (change >= 0) {
                    currentGain = change;
                } else {
                    currentLoss = Math.abs(change);
                }
                
                avgGain = (avgGain * (period - 1) + currentGain) / period;
                avgLoss = (avgLoss * (period - 1) + currentLoss) / period;
                rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
                rsiValues.push(100 - (100 / (1 + rs)));
            }
            
            // Pad with nulls for the initial period
            return Array(period).fill(null).concat(rsiValues);
        }

        // Calculate MACD (Moving Average Convergence Divergence)
        function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
            const fastEMA = calculateEMA(prices, fastPeriod);
            const slowEMA = calculateEMA(prices, slowPeriod);
            
            // Calculate MACD line
            const macdLine = [];
            for (let i = 0; i < prices.length; i++) {
                macdLine.push(fastEMA[i] - slowEMA[i]);
            }
            
            // Calculate signal line (EMA of MACD line)
            const signalLine = calculateEMA(macdLine, signalPeriod);
            
            // Calculate histogram
            const histogram = [];
            for (let i = 0; i < prices.length; i++) {
                histogram.push(macdLine[i] - signalLine[i]);
            }
            
            return {
                macdLine,
                signalLine,
                histogram
            };
        }

        // Calculate Bollinger Bands
        function calculateBollingerBands(prices, period = 20, multiplier = 2) {
            const upperBand = [];
            const middleBand = [];
            const lowerBand = [];
            
            for (let i = period - 1; i < prices.length; i++) {
                const slice = prices.slice(i - period + 1, i + 1);
                const mean = slice.reduce((sum, val) => sum + val, 0) / period;
                const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
                const stdDev = Math.sqrt(variance);
                
                middleBand.push(mean);
                upperBand.push(mean + (stdDev * multiplier));
                lowerBand.push(mean - (stdDev * multiplier));
            }
            
            // Pad with nulls for the initial period
            const nulls = Array(period - 1).fill(null);
            return {
                upper: nulls.concat(upperBand),
                middle: nulls.concat(middleBand),
                lower: nulls.concat(lowerBand)
            };
        }

        // Calculate Fibonacci Retracement Levels
        function calculateFibonacciRetracement(prices) {
            const high = Math.max(...prices);
            const low = Math.min(...prices);
            const diff = high - low;
            
            return {
                level0: high,
                level23: high - diff * 0.236,
                level38: high - diff * 0.382,
                level50: high - diff * 0.5,
                level61: high - diff * 0.618,
                level78: high - diff * 0.786,
                level100: low
            };
        }

        // Calculate Fear and Greed Index (simulated)
        async function fetchFearAndGreedIndex() {
            try {
                // In a real app, we'd fetch from alternative.me API
                // Simulating with random values between 0-100
                return Math.floor(Math.random() * 100);
            } catch (error) {
                console.error('Error fetching fear and greed index:', error);
                return 50; // Neutral as fallback
            }
        }

        // Calculate Social Volume (simulated)
        async function fetchSocialVolume(coinId) {
            try {
                // In a real app, we'd fetch from Santiment or similar
                // Simulating with random values
                return {
                    twitter: Math.floor(Math.random() * 10000),
                    reddit: Math.floor(Math.random() * 5000),
                    telegram: Math.floor(Math.random() * 3000)
                };
            } catch (error) {
                console.error('Error fetching social volume:', error);
                return {
                    twitter: 0,
                    reddit: 0,
                    telegram: 0
                };
            }
        }

        // Calculate On-Chain Metrics (simulated)
        async function fetchOnChainMetrics(coinId) {
            try {
                // In a real app, we'd fetch from Glassnode, CoinMetrics, etc.
                // Simulating with random values
                return {
                    activeAddresses: Math.floor(Math.random() * 100000),
                    transactionVolume: Math.floor(Math.random() * 1000000),
                    exchangeInflows: Math.floor(Math.random() * 50000),
                    exchangeOutflows: Math.floor(Math.random() * 50000),
                    whaleTransactions: Math.floor(Math.random() * 1000)
                };
            } catch (error) {
                console.error('Error fetching on-chain metrics:', error);
                return {
                    activeAddresses: 0,
                    transactionVolume: 0,
                    exchangeInflows: 0,
                    exchangeOutflows: 0,
                    whaleTransactions: 0
                };
            }
        }

        // Calculate Depth of Market (simulated)
        async function fetchDepthOfMarket(coinId) {
            try {
                // In a real app, we'd fetch from exchange API
                // Simulating with random values
                return {
                    bids: [
                        { price: 0.99, amount: Math.random() * 100 },
                        { price: 0.98, amount: Math.random() * 200 },
                        { price: 0.97, amount: Math.random() * 300 }
                    ],
                    asks: [
                        { price: 1.01, amount: Math.random() * 100 },
                        { price: 1.02, amount: Math.random() * 200 },
                        { price: 1.03, amount: Math.random() * 300 }
                    ]
                };
            } catch (error) {
                console.error('Error fetching depth of market:', error);
                return {
                    bids: [],
                    asks: []
                };
            }
        }

        // Generate AI suggestions based on comprehensive market data
        async function generateAISuggestions() {
            try {
                // Focus on top 10 coins for suggestions
                const topCoins = allCoins.slice(0, 10);
                const suggestions = [];
                
                // Get fear and greed index once for all coins
                const fearGreedIndex = await fetchFearAndGreedIndex();
                
                // Analyze each coin
                for (const coin of topCoins) {
                    try {
                        // Get detailed data for analysis
                        const detailsResponse = await fetchWithRetry(`https://api.coingecko.com/api/v3/coins/${coin.id}`);
                        const detailsData = await detailsResponse.json();
                        
                        // Get price history for analysis
                        const chartResponse = await fetchWithRetry(`https://api.coingecko.com/api/v3/coins/${coin.id}/market_chart?vs_currency=usd&days=30`);
                        const chartData = await chartResponse.json();
                        
                        // Get additional metrics
                        const socialVolume = await fetchSocialVolume(coin.id);
                        const onChainMetrics = await fetchOnChainMetrics(coin.id);
                        const depthOfMarket = await fetchDepthOfMarket(coin.id);
                        
                        // Extract price and volume data
                        const prices = chartData.prices.map(p => p[1]);
                        const volumes = chartData.total_volumes.map(v => v[1]);
                        
                        // Calculate technical indicators
                        const ema20 = calculateEMA(prices, 20);
                        const ema50 = calculateEMA(prices, 50);
                        const ema200 = calculateEMA(prices, 200);
                        const vwma = calculateVWMA(prices, volumes, 20);
                        const rsi = calculateRSI(prices);
                        const macd = calculateMACD(prices);
                        const bollinger = calculateBollingerBands(prices);
                        const fib = calculateFibonacciRetracement(prices);
                        
                        // Current metrics
                        const currentPrice = detailsData.market_data.current_price.usd;
                        const priceChange24h = detailsData.market_data.price_change_percentage_24h;
                        const priceChange7d = detailsData.market_data.price_change_percentage_7d;
                        const marketCap = detailsData.market_data.market_cap.usd;
                        const volume = detailsData.market_data.total_volume.usd;
                        const lastRSI = rsi[rsi.length - 1];
                        const lastMACD = macd.macdLine[macd.macdLine.length - 1];
                        const lastSignal = macd.signalLine[macd.signalLine.length - 1];
                        
                        // Calculate composite score (0-100)
                        let score = 50; // Neutral baseline
                        
                        // Price momentum (20%)
                        if (priceChange24h > 5) score += 10;
                        else if (priceChange24h > 2) score += 5;
                        else if (priceChange24h < -5) score -= 10;
                        else if (priceChange24h < -2) score -= 5;
                        
                        // Volume (15%)
                        if (volume > marketCap * 0.2) score += 7.5;
                        else if (volume > marketCap * 0.1) score += 3.75;
                        else if (volume < marketCap * 0.05) score -= 3.75;
                        
                        // RSI (10%)
                        if (lastRSI < 30) score += 5; // Oversold
                        else if (lastRSI > 70) score -= 5; // Overbought
                        
                        // MACD (10%)
                        if (lastMACD > lastSignal) score += 5; // Bullish crossover
                        else if (lastMACD < lastSignal) score -= 5; // Bearish crossover
                        
                        // EMA (10%)
                        if (ema20[ema20.length - 1] > ema50[ema50.length - 1] && 
                            ema50[ema50.length - 1] > ema200[ema200.length - 1]) {
                            score += 5; // Bullish alignment
                        } else if (ema20[ema20.length - 1] < ema50[ema50.length - 1] && 
                                   ema50[ema50.length - 1] < ema200[ema200.length - 1]) {
                            score -= 5; // Bearish alignment
                        }
                        
                        // Social volume (10%)
                        const totalSocial = socialVolume.twitter + socialVolume.reddit + socialVolume.telegram;
                        if (totalSocial > 10000) score += 5;
                        else if (totalSocial < 2000) score -= 2.5;
                        
                        // On-chain metrics (15%)
                        if (onChainMetrics.activeAddresses > 50000) score += 3.75;
                        if (onChainMetrics.exchangeOutflows > onChainMetrics.exchangeInflows * 1.5) score += 3.75;
                        if (onChainMetrics.whaleTransactions > 500) score += 3.75;
                        
                        // Fear and greed (10%)
                        if (fearGreedIndex < 30) score += 5; // Fear - good buying opportunity
                        else if (fearGreedIndex > 70) score -= 5; // Greed - possible pullback
                        
                        // Normalize score to 0-100
                        score = Math.max(0, Math.min(100, score));
                        
                        // Determine suggestion based on score
                        let suggestion = '';
                        let reason = '';
                        let action = '';
                        
                        if (score >= 70) {
                            action = 'buy';
                            suggestion = 'Strong Buy';
                            reason = `Composite score: ${Math.round(score)}/100 (Bullish)`;
                        } else if (score >= 55) {
                            action = 'buy';
                            suggestion = 'Buy';
                            reason = `Composite score: ${Math.round(score)}/100 (Mildly Bullish)`;
                        } else if (score <= 30) {
                            action = 'sell';
                            suggestion = 'Strong Sell';
                            reason = `Composite score: ${Math.round(score)}/100 (Bearish)`;
                        } else if (score <= 45) {
                            action = 'sell';
                            suggestion = 'Sell';
                            reason = `Composite score: ${Math.round(score)}/100 (Mildly Bearish)`;
                        } else {
                            action = 'hold';
                            suggestion = 'Hold';
                            reason = `Composite score: ${Math.round(score)}/100 (Neutral)`;
                        }
                        
                        // Add additional reasoning based on indicators
                        if (lastRSI < 30 && action !== 'buy') {
                            reason += ' | Oversold (RSI)';
                            if (action === 'hold') action = 'buy';
                        }
                        if (lastRSI > 70 && action !== 'sell') {
                            reason += ' | Overbought (RSI)';
                            if (action === 'hold') action = 'sell';
                        }
                        if (currentPrice < bollinger.lower[bollinger.lower.length - 1] && action !== 'buy') {
                            reason += ' | Below Lower Bollinger Band';
                            if (action === 'hold') action = 'buy';
                        }
                        if (currentPrice > bollinger.upper[bollinger.upper.length - 1] && action !== 'sell') {
                            reason += ' | Above Upper Bollinger Band';
                            if (action === 'hold') action = 'sell';
                        }
                        
                        suggestions.push({
                            id: coin.id,
                            name: coin.name,
                            symbol: coin.symbol,
                            image: coin.image,
                            action: action,
                            suggestion: suggestion,
                            reason: reason,
                            price: currentPrice,
                            change24h: priceChange24h,
                            score: score
                        });
                        
                    } catch (error) {
                        console.error(`Error analyzing ${coin.name}:`, error);
                    }
                }
                
                // Sort suggestions by score (highest first)
                suggestions.sort((a, b) => b.score - a.score);
                
                // Display the top 3 suggestions
                displayAISuggestions(suggestions.slice(0, 3));
                
            } catch (error) {
                console.error('Error generating AI suggestions:', error);
                suggestionsList.innerHTML = `
                    <div class="error-message">
                        Failed to load suggestions. ${error.message}
                        <button class="retry-btn" id="retrySuggestions">Retry</button>
                    </div>
                `;
                document.getElementById('retrySuggestions').addEventListener('click', generateAISuggestions);
            }
        }
        
        // Display AI suggestions
        function displayAISuggestions(suggestions) {
            suggestionsList.innerHTML = '';
            
            if (suggestions.length === 0) {
                suggestionsList.innerHTML = '<div class="error-message">No suggestions available at this time</div>';
                return;
            }
            
            suggestions.forEach(suggestion => {
                const suggestionCard = document.createElement('div');
                suggestionCard.className = 'suggestion-card';
                
                // Check if this is a premium coin (not in top 10)
                const isPremiumCoin = allCoins.findIndex(c => c.id === suggestion.id) >= 10;
                
                suggestionCard.innerHTML = `
                    <img src="${suggestion.image}" alt="${suggestion.name}" class="suggestion-icon" onerror="this.src='https://via.placeholder.com/40'">
                    <div class="suggestion-details">
                        <div class="suggestion-name">${suggestion.name} (${suggestion.symbol.toUpperCase()})</div>
                        <div class="suggestion-reason">${suggestion.reason}</div>
                    </div>
                    <div class="suggestion-action ${suggestion.action}">${suggestion.suggestion}</div>
                    ${isPremiumCoin ? `<div class="premium-lock"><i class="fas fa-lock"></i> PRO</div>` : ''}
                `;
                
                // Make the suggestion card clickable to load that coin's details
                suggestionCard.addEventListener('click', () => {
                    if (isPremiumCoin && !isPremiumUser) {
                        premiumModal.classList.add('active');
                        return;
                    }
                    
                    loadCoinDetails(suggestion.id);
                    currentCoin = suggestion.id;
                    
                    // Update active state in coin list
                    document.querySelectorAll('.coin-item').forEach(item => {
                        item.classList.remove('active');
                        if (item.dataset.id === suggestion.id) {
                            item.classList.add('active');
                        }
                    });
                });
                
                suggestionsList.appendChild(suggestionCard);
            });
        }
        
        // Fetch top 100 cryptocurrencies by market cap with error handling
        async function fetchTopCryptocurrencies() {
            try {
                console.log("Fetching top cryptocurrencies...");
                
                // Show skeleton loading
                coinListElement.innerHTML = `
                    <div class="skeleton-loader" style="height: 60px; margin-bottom: 8px;"></div>
                    <div class="skeleton-loader" style="height: 60px; margin-bottom: 8px;"></div>
                    <div class="skeleton-loader" style="height: 60px; margin-bottom: 8px;"></div>
                    <div class="skeleton-loader" style="height: 60px; margin-bottom: 8px;"></div>
                    <div class="skeleton-loader" style="height: 60px; margin-bottom: 8px;"></div>
                `;
                
                const response = await fetchWithRetry(
                    'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false'
                );
                
                allCoins = await response.json();
                console.log("Successfully fetched coins:", allCoins.length);
                
                displayCoinList(allCoins);
                
                // Generate AI suggestions
                generateAISuggestions();
                
                // Load details for the first coin by default
                if (allCoins.length > 0) {
                    loadCoinDetails(allCoins[0].id);
                    currentCoin = allCoins[0].id;
                }
            } catch (error) {
                console.error('Error fetching cryptocurrencies:', error);
                coinListElement.innerHTML = `
                    <div class="error-message">
                        Failed to load cryptocurrency list. ${error.message}
                        <button class="retry-btn" id="retryList">Retry</button>
                    </div>
                `;
                document.getElementById('retryList').addEventListener('click', fetchTopCryptocurrencies);
            }
        }
        
        // Display the list of coins
        function displayCoinList(coins) {
            coinListElement.innerHTML = '';
            
            if (coins.length === 0) {
                coinListElement.innerHTML = '<div class="error-message">No cryptocurrencies found matching your search</div>';
                return;
            }
            
            coins.forEach((coin, index) => {
                const coinItem = document.createElement('div');
                coinItem.className = `coin-item ${currentCoin === coin.id ? 'active' : ''} ${index >= 10 ? 'premium' : ''}`;
                coinItem.dataset.id = coin.id;
                coinItem.innerHTML = `
                    <img src="${coin.image}" alt="${coin.name}" class="coin-icon" onerror="this.src='https://via.placeholder.com/30'">
                    <div class="coin-name">${coin.name}</div>
                    <div class="coin-symbol">${coin.symbol.toUpperCase()}</div>
                `;
                
                coinItem.addEventListener('click', async () => {
                    // Check if this is a premium coin (not in top 10)
                    if (index >= 10 && !isPremiumUser) {
                        premiumModal.classList.add('active');
                        return;
                    }
                    
                    // Remove active class from all items
                    document.querySelectorAll('.coin-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    
                    // Add active class to clicked item
                    coinItem.classList.add('active');
                    
                    // Load coin details
                    try {
                        await loadCoinDetails(coin.id);
                        currentCoin = coin.id;
                    } catch (error) {
                        console.error('Error loading coin details:', error);
                    }
                });
                
                coinListElement.appendChild(coinItem);
            });
        }
        
        // Load detailed information for a specific coin
        async function loadCoinDetails(coinId) {
            try {
                console.log(`Loading details for coin: ${coinId}`);
                
                // Show skeleton loading
                coinDetailElement.innerHTML = `
                    <div class="suggestions-section" id="suggestionsSection">
                        <div class="suggestions-header">
                            <h3><i class="fas fa-robot"></i> Today's AI Suggestions</h3>
                            <div class="accuracy-badge">
                                <i class="fas fa-bolt"></i> 95% Accuracy
                            </div>
                            <div class="gamification-badge">
                                <i class="fas fa-trophy"></i> Top 5% Analyst
                            </div>
                        </div>
                        <div id="suggestionsList">
                            ${suggestionsList.innerHTML}
                        </div>
                    </div>
                    
                    <div class="weather-report">
                        <div class="weather-icon">
                            <i class="fas fa-cloud-sun"></i>
                        </div>
                        <div class="weather-details">
                            <div class="weather-title">Crypto Weather Report</div>
                            <div class="weather-description" id="weatherDescription">Loading market climate...</div>
                        </div>
                    </div>
                    
                    <div class="reality-check">
                        <h4><i class="fas fa-brain"></i> AI Reality Check</h4>
                        <div id="realityCheckText">Analyzing your recent predictions for cognitive biases...</div>
                    </div>
                    
                    <div class="tarot-card">
                        <h4><i class="fas fa-magic"></i> Crypto Tarot</h4>
                        <div class="tarot-image" id="tarotImage">
                            <i class="fas fa-question"></i>
                        </div>
                        <div class="tarot-meaning" id="tarotMeaning">Drawing your daily crypto fortune...</div>
                    </div>
                    
                    <div class="meme-analysis">
                        <h4><i class="fas fa-grin-squint-tears"></i> Meme Impact Analysis</h4>
                        <div class="meme-score">
                            <span>Sentiment:</span>
                            <div class="meme-score-bar">
                                <div class="meme-score-fill" id="memeScoreFill" style="width: 0%"></div>
                            </div>
                            <div class="meme-score-value" id="memeScoreValue">0%</div>
                        </div>
                        <div class="meme-impact" id="memeImpact">Analyzing latest meme trends...</div>
                    </div>
                    
                    <div class="bingo-card-container">
                        <h4><i class="fas fa-th-large"></i> Prediction Bingo</h4>
                        <div class="bingo-progress">
                            <div class="bingo-progress-bar" id="bingoProgressBar" style="width: 0%"></div>
                        </div>
                        <div class="bingo-card" id="bingoCard">
                            <!-- Filled by JavaScript -->
                        </div>
                    </div>
                    
                    <div class="skeleton-loader" style="height: 80px; margin-bottom: 20px;"></div>
                    <div class="skeleton-loader" style="height: 40px; margin-bottom: 20px; width: 80%;"></div>
                    <div class="skeleton-loader" style="height: 400px; margin-bottom: 30px;"></div>
                    <div class="skeleton-loader" style="height: 40px; margin-bottom: 20px; width: 60%;"></div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px;">
                        <div class="skeleton-loader" style="height: 150px;"></div>
                        <div class="skeleton-loader" style="height: 150px;"></div>
                        <div class="skeleton-loader" style="height: 150px;"></div>
                    </div>
                `;
                
                // Determine days parameter based on current time range
                const days = currentTimeRange === '1d' ? 1 : 
                            currentTimeRange === '7d' ? 7 : 
                            currentTimeRange === '30d' ? 30 : 
                            currentTimeRange === '90d' ? 90 : 365;
                
                // Fetch both coin details and chart data in parallel with retries
                const [detailsResponse, chartResponse] = await Promise.all([
                    fetchWithRetry(`https://api.coingecko.com/api/v3/coins/${coinId}`),
                    fetchWithRetry(`https://api.coingecko.com/api/v3/coins/${coinId}/market_chart?vs_currency=usd&days=${days}`)
                ]);
                
                const detailsData = await detailsResponse.json();
                const chartData = await chartResponse.json();
                
                // Fetch additional metrics for premium users
                let onChainMetrics = {};
                let socialVolume = {};
                let fearGreedIndex = 50;
                
                if (isPremiumUser) {
                    [onChainMetrics, socialVolume, fearGreedIndex] = await Promise.all([
                        fetchOnChainMetrics(coinId),
                        fetchSocialVolume(coinId),
                        fetchFearAndGreedIndex()
                    ]);
                }
                
                console.log(`Successfully loaded details for ${coinId}`);
                
                // Generate predictions with proper dates starting from today
                const predictions = generateAdvancedPredictions(detailsData.market_data.current_price.usd, chartData.prices, chartData.total_volumes);
                
                // Display the coin details
                displayCoinDetails(detailsData, chartData, predictions, onChainMetrics, socialVolume, fearGreedIndex);
            } catch (error) {
                console.error('Error fetching coin details:', error);
                coinDetailElement.innerHTML = `
                    <div class="suggestions-section" id="suggestionsSection">
                        <div class="suggestions-header">
                            <h3><i class="fas fa-robot"></i> Today's AI Suggestions</h3>
                            <div class="accuracy-badge">
                                <i class="fas fa-bolt"></i> 95% Accuracy
                            </div>
                            <div class="gamification-badge">
                                <i class="fas fa-trophy"></i> Top 5% Analyst
                            </div>
                        </div>
                        <div id="suggestionsList">
                            ${suggestionsList.innerHTML}
                        </div>
                    </div>
                    
                    <div class="weather-report">
                        <div class="weather-icon">
                            <i class="fas fa-cloud-sun"></i>
                        </div>
                        <div class="weather-details">
                            <div class="weather-title">Crypto Weather Report</div>
                            <div class="weather-description" id="weatherDescription">Loading market climate...</div>
                        </div>
                    </div>
                    
                    <div class="reality-check">
                        <h4><i class="fas fa-brain"></i> AI Reality Check</h4>
                        <div id="realityCheckText">Analyzing your recent predictions for cognitive biases...</div>
                    </div>
                    
                    <div class="error-message">
                        Failed to load coin details. ${error.message}
                        <button class="retry-btn" id="retryDetails">Retry</button>
                    </div>
                `;
                document.getElementById('retryDetails').addEventListener('click', () => loadCoinDetails(coinId));
            }
        }
        
        // Display detailed information for a coin
        function displayCoinDetails(coinData, chartData, predictions, onChainMetrics = {}, socialVolume = {}, fearGreedIndex = 50) {
            const currentPrice = coinData.market_data.current_price.usd;
            const priceChange24h = coinData.market_data.price_change_percentage_24h;
            const priceChange7d = coinData.market_data.price_change_percentage_7d;
            const priceChange30d = coinData.market_data.price_change_percentage_30d;
            const marketCap = coinData.market_data.market_cap.usd;
            const volume = coinData.market_data.total_volume.usd;
            const priceChangeClass = priceChange24h > 0 ? 'positive' : priceChange24h < 0 ? 'negative' : 'neutral';
            
            // Prepare historical data for chart
            const historicalData = chartData.prices.map(price => ({
                x: new Date(price[0]),
                y: price[1]
            }));
            
            // Prepare volume data
            const volumeData = chartData.total_volumes.map(vol => ({
                x: new Date(vol[0]),
                y: vol[1]
            }));
            
            // Calculate technical indicators
            const prices = chartData.prices.map(p => p[1]);
            const volumes = chartData.total_volumes.map(v => v[1]);
            
            const ema20 = calculateEMA(prices, 20);
            const ema50 = calculateEMA(prices, 50);
            const ema200 = calculateEMA(prices, 200);
            const vwma = calculateVWMA(prices, volumes, 20);
            const rsi = calculateRSI(prices);
            const macd = calculateMACD(prices);
            const bollinger = calculateBollingerBands(prices);
            const fib = calculateFibonacciRetracement(prices);
            
            // Prepare prediction data for chart
            const predictionData = [...historicalData];
            predictions.forEach(pred => {
                predictionData.push({
                    x: new Date(pred.date),
                    y: pred.price
                });
            });
            
            coinDetailElement.innerHTML = `
                <div class="suggestions-section" id="suggestionsSection">
                    <div class="suggestions-header">
                        <h3><i class="fas fa-robot"></i> Today's AI Suggestions</h3>
                        <div class="accuracy-badge">
                            <i class="fas fa-bolt"></i> 95% Accuracy
                        </div>
                        <div class="gamification-badge">
                            <i class="fas fa-trophy"></i> Top 5% Analyst
                        </div>
                    </div>
                    <div id="suggestionsList">
                        ${suggestionsList.innerHTML}
                    </div>
                </div>
                
                <div class="weather-report">
                    <div class="weather-icon">
                        <i class="fas fa-cloud-sun"></i>
                    </div>
                    <div class="weather-details">
                        <div class="weather-title">Crypto Weather Report</div>
                        <div class="weather-description" id="weatherDescription">${generateCryptoWeather()}</div>
                    </div>
                </div>
                
                <div class="reality-check">
                    <h4><i class="fas fa-brain"></i> AI Reality Check</h4>
                    <div id="realityCheckText">${generateRealityCheck()}</div>
                </div>
                
                <div class="tarot-card">
                    <h4><i class="fas fa-magic"></i> Crypto Tarot</h4>
                    <div class="tarot-image" id="tarotImage">
                        ${drawTarotCard().image}
                    </div>
                    <div class="tarot-meaning" id="tarotMeaning">${drawTarotCard().meaning}</div>
                </div>
                
                <div class="meme-analysis">
                    <h4><i class="fas fa-grin-squint-tears"></i> Meme Impact Analysis</h4>
                    <div class="meme-score">
                        <span>Sentiment:</span>
                        <div class="meme-score-bar">
                            <div class="meme-score-fill" id="memeScoreFill" style="width: ${analyzeMemeImpact().score}%"></div>
                        </div>
                        <div class="meme-score-value" id="memeScoreValue">${analyzeMemeImpact().score}%</div>
                    </div>
                    <div class="meme-impact" id="memeImpact">${analyzeMemeImpact().impact}</div>
                </div>
                
                <div class="bingo-card-container">
                    <h4><i class="fas fa-th-large"></i> Prediction Bingo</h4>
                    <div class="bingo-progress">
                        <div class="bingo-progress-bar" id="bingoProgressBar" style="width: ${(markedBingoSquares.length / 25 * 100)}%"></div>
                    </div>
                    <div class="bingo-card" id="bingoCard">
                        ${generateBingoCardHTML()}
                    </div>
                </div>
                
                <div class="coin-header">
                    <div class="coin-title">
                        <img src="${coinData.image.large}" alt="${coinData.name}" class="large-coin-icon" onerror="this.src='https://via.placeholder.com/50'">
                        <div class="coin-title-text">
                            <h2>${coinData.name}</h2>
                            <span>${coinData.symbol.toUpperCase()}</span>
                        </div>
                    </div>
                    <div class="price-display">
                        <div class="current-price">$${currentPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 })}</div>
                        <div class="price-change ${priceChangeClass}">
                            ${priceChange24h > 0 ? '+' : ''}${priceChange24h.toFixed(2)}%
                        </div>
                    </div>
                </div>
                
                ${isPremiumUser ? `
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-title">Market Cap</div>
                        <div class="metric-value">$${(marketCap / 1000000000).toFixed(2)}B</div>
                        <div class="metric-change ${priceChange7d > 0 ? 'positive' : 'negative'}">
                            ${priceChange7d > 0 ? '+' : ''}${priceChange7d.toFixed(2)}% (7D)
                        </div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Volume (24h)</div>
                        <div class="metric-value">$${(volume / 1000000).toFixed(2)}M</div>
                        <div class="metric-change ${priceChange24h > 0 ? 'positive' : 'negative'}">
                            ${priceChange24h > 0 ? '+' : ''}${priceChange24h.toFixed(2)}%
                        </div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">RSI (14)</div>
                        <div class="metric-value">${rsi[rsi.length - 1] ? rsi[rsi.length - 1].toFixed(2) : 'N/A'}</div>
                        <div class="metric-change ${rsi[rsi.length - 1] < 30 ? 'positive' : rsi[rsi.length - 1] > 70 ? 'negative' : 'neutral'}">
                            ${rsi[rsi.length - 1] < 30 ? 'Oversold' : rsi[rsi.length - 1] > 70 ? 'Overbought' : 'Neutral'}
                        </div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Fear & Greed</div>
                        <div class="metric-value">${fearGreedIndex}/100</div>
                        <div class="metric-change ${fearGreedIndex < 30 ? 'positive' : fearGreedIndex > 70 ? 'negative' : 'neutral'}">
                            ${fearGreedIndex < 30 ? 'Extreme Fear' : fearGreedIndex > 70 ? 'Extreme Greed' : 'Neutral'}
                        </div>
                    </div>
                </div>
                ` : ''}
                
                <div class="time-filters">
                    <button class="time-btn ${currentTimeRange === '1d' ? 'active' : ''}" data-range="1d">24H</button>
                    <button class="time-btn ${currentTimeRange === '7d' ? 'active' : ''}" data-range="7d">7D</button>
                    <button class="time-btn ${currentTimeRange === '30d' ? 'active' : ''}" data-range="30d">30D</button>
                    <button class="time-btn ${currentTimeRange === '90d' ? 'active' : ''}" data-range="90d">90D</button>
                    <button class="time-btn ${currentTimeRange === '1y' ? 'active' : ''}" data-range="1y">1Y</button>
                </div>
                
                ${isPremiumUser ? `
                <div class="technical-indicators">
                    <button class="indicator-btn ${activeIndicators.includes('ema') ? 'active' : ''}" data-indicator="ema">EMA</button>
                    <button class="indicator-btn ${activeIndicators.includes('vwma') ? 'active' : ''}" data-indicator="vwma">VWMA</button>
                    <button class="indicator-btn ${activeIndicators.includes('rsi') ? 'active' : ''}" data-indicator="rsi">RSI</button>
                    <button class="indicator-btn ${activeIndicators.includes('macd') ? 'active' : ''}" data-indicator="macd">MACD</button>
                    <button class="indicator-btn ${activeIndicators.includes('bollinger') ? 'active' : ''}" data-indicator="bollinger">Bollinger</button>
                    <button class="indicator-btn ${activeIndicators.includes('fib') ? 'active' : ''}" data-indicator="fib">Fibonacci</button>
                </div>
                ` : ''}
                
                <div class="chart-container">
                    <canvas id="priceChart"></canvas>
                </div>
                
                <div class="prediction-section">
                    <div class="prediction-header">
                        <h3><i class="fas fa-crystal-ball"></i> AI Price Predictions</h3>
                        <div class="prediction-period">Next 30 Days</div>
                        <div class="accuracy-badge">
                            <i class="fas fa-bolt"></i> 95% Historical Accuracy
                        </div>
                    </div>
                    
                    <div class="prediction-cards" id="predictionCards">
                        ${predictions.slice(0, 3).map(pred => `
                            <div class="prediction-card">
                                <div class="prediction-date">${formatDisplayDate(new Date(pred.date))}</div>
                                <div class="prediction-price">$${pred.price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 })}</div>
                                <div class="prediction-change ${pred.change > 0 ? 'positive' : 'negative'}">
                                    ${pred.change > 0 ? '+' : ''}${pred.change.toFixed(2)}%
                                </div>
                                <div class="prediction-confidence">
                                    <div>Confidence: ${pred.confidence}%</div>
                                    <div class="confidence-bar">
                                        <div class="confidence-level" style="width: ${pred.confidence}%"></div>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                ${!isPremiumUser ? `
                <div class="premium-feature" style="margin-top: 30px; padding: 20px; border-radius: 10px;">
                    <h3><i class="fas fa-crown"></i> Unlock Advanced Features</h3>
                    <p>Get access to 15+ technical indicators, on-chain metrics, whale activity tracking, and 1-year predictions with 90%+ confidence.</p>
                    <button class="subscribe-btn" style="margin-top: 15px; width: auto;" id="showPremium">Upgrade to PRO</button>
                </div>
                ` : ''}
            `;
            
            // Setup time filter buttons
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentTimeRange = btn.dataset.range;
                    loadCoinDetails(currentCoin);
                });
            });
            
            // Setup indicator buttons for premium users
            if (isPremiumUser) {
                document.querySelectorAll('.indicator-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const indicator = btn.dataset.indicator;
                        if (activeIndicators.includes(indicator)) {
                            activeIndicators = activeIndicators.filter(i => i !== indicator);
                            btn.classList.remove('active');
                        } else {
                            activeIndicators.push(indicator);
                            btn.classList.add('active');
                        }
                        initializeChart(historicalData, predictionData, prices, volumes);
                    });
                });
            }
            
            // Setup premium button
            if (!isPremiumUser) {
                document.getElementById('showPremium').addEventListener('click', () => {
                    premiumModal.classList.add('active');
                });
            }
            
            // Setup bingo card squares
            document.querySelectorAll('.bingo-square').forEach(square => {
                square.addEventListener('click', () => {
                    const index = parseInt(square.dataset.index);
                    if (!markedBingoSquares.includes(index)) {
                        markedBingoSquares.push(index);
                        square.classList.add('marked');
                        updateBingoProgress();
                    }
                });
            });
            
            // Initialize the chart with proper date formatting
            initializeChart(historicalData, predictionData, prices, volumes);
        }
        
        // Initialize the price chart with proper date tooltips
        function initializeChart(historicalData, predictionData, prices = [], volumes = []) {
            const ctx = document.getElementById('priceChart').getContext('2d');
            
            if (priceChart) {
                priceChart.destroy();
            }
            
            // Find the split point between historical and prediction data
            const splitIndex = historicalData.length;
            
            // Prepare datasets based on active indicators
            const datasets = [
                {
                    label: 'Price',
                    data: historicalData,
                    borderColor: 'rgba(110, 59, 255, 1)',
                    backgroundColor: 'rgba(110, 59, 255, 0.1)',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.4,
                    yAxisID: 'y',
                    fill: true
                },
                {
                    label: 'Predicted Price',
                    data: predictionData.slice(splitIndex - 1), // Connect to last historical point
                    borderColor: 'rgba(0, 212, 255, 1)',
                    backgroundColor: 'rgba(0, 212, 255, 0.1)',
                    borderWidth: 2,
                    pointRadius: 0,
                    borderDash: [5, 5],
                    tension: 0.4,
                    yAxisID: 'y',
                    fill: false
                }
            ];
            
            // Add volume bars (secondary axis)
            if (isPremiumUser && activeIndicators.includes('vwma')) {
                datasets.push({
                    label: 'Volume',
                    data: volumes.map((vol, i) => ({
                        x: historicalData[i]?.x || new Date(),
                        y: vol.y
                    })),
                    type: 'bar',
                    backgroundColor: 'rgba(255, 255, 255, 0.1)',
                    borderColor: 'rgba(255, 255, 255, 0.3)',
                    borderWidth: 1,
                    yAxisID: 'y1'
                });
            }
            
            // Add EMA indicators if active
            if (isPremiumUser && activeIndicators.includes('ema') && prices.length > 0) {
                const ema20 = calculateEMA(prices.map(p => p.y), 20);
                const ema50 = calculateEMA(prices.map(p => p.y), 50);
                const ema200 = calculateEMA(prices.map(p => p.y), 200);
                
                datasets.push({
                    label: 'EMA 20',
                    data: historicalData.map((point, i) => ({
                        x: point.x,
                        y: ema20[i]
                    })),
                    borderColor: 'rgba(255, 99, 132, 1)',
                    borderWidth: 1,
                    pointRadius: 0,
                    tension: 0.1,
                    yAxisID: 'y'
                });
                
                datasets.push({
                    label: 'EMA 50',
                    data: historicalData.map((point, i) => ({
                        x: point.x,
                        y: ema50[i]
                    })),
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1,
                    pointRadius: 0,
                    tension: 0.1,
                    yAxisID: 'y'
                });
                
                datasets.push({
                    label: 'EMA 200',
                    data: historicalData.map((point, i) => ({
                        x: point.x,
                        y: ema200[i]
                    })),
                    borderColor: 'rgba(255, 159, 64, 1)',
                    borderWidth: 1,
                    pointRadius: 0,
                    tension: 0.1,
                    yAxisID: 'y'
                });
            }
            
            // Add VWMA if active
            if (isPremiumUser && activeIndicators.includes('vwma') && prices.length > 0 && volumes.length > 0) {
                const vwma = calculateVWMA(
                    prices.map(p => p.y),
                    volumes.map(v => v.y),
                    20
                );
                
                datasets.push({
                    label: 'VWMA 20',
                    data: historicalData.map((point, i) => ({
                        x: point.x,
                        y: vwma[i]
                    })),
                    borderColor: 'rgba(75, 192, 192, 1)',
                    borderWidth: 1,
                    pointRadius: 0,
                    tension: 0.1,
                    yAxisID: 'y'
                });
            }
            
            // Add Bollinger Bands if active
            if (isPremiumUser && activeIndicators.includes('bollinger') && prices.length > 0) {
                const bb = calculateBollingerBands(prices.map(p => p.y));
                
                datasets.push({
                    label: 'Bollinger Upper',
                    data: historicalData.map((point, i) => ({
                        x: point.x,
                        y: bb.upper[i]
                    })),
                    borderColor: 'rgba(153, 102, 255, 0.7)',
                    borderWidth: 1,
                    pointRadius: 0,
                    tension: 0.1,
                    yAxisID: 'y'
                });
                
                datasets.push({
                    label: 'Bollinger Middle',
                    data: historicalData.map((point, i) => ({
                        x: point.x,
                        y: bb.middle[i]
                    })),
                    borderColor: 'rgba(153, 102, 255, 0.5)',
                    borderWidth: 1,
                    pointRadius: 0,
                    tension: 0.1,
                    yAxisID: 'y'
                });
                
                datasets.push({
                    label: 'Bollinger Lower',
                    data: historicalData.map((point, i) => ({
                        x: point.x,
                        y: bb.lower[i]
                    })),
                    borderColor: 'rgba(153, 102, 255, 0.7)',
                    borderWidth: 1,
                    pointRadius: 0,
                    tension: 0.1,
                    yAxisID: 'y'
                });
            }
            
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: currentTimeRange === '1d' ? 'hour' : 
                                      currentTimeRange === '7d' ? 'day' : 
                                      currentTimeRange === '30d' ? 'day' : 'month',
                                tooltipFormat: 'MMM d, yyyy',
                                displayFormats: {
                                    hour: 'MMM d, hA',
                                    day: 'MMM d',
                                    month: 'MMM yyyy'
                                }
                            },
                            grid: {
                                display: false
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: isPremiumUser && activeIndicators.includes('vwma'),
                            position: 'right',
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                callback: function(value) {
                                    return (value / 1000000).toFixed(1) + 'M';
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return formatTooltipDate(new Date(context[0].parsed.x));
                                },
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.dataset.yAxisID === 'y1') {
                                        label += (context.parsed.y / 1000000).toFixed(2) + 'M';
                                    } else {
                                        label += '$' + context.parsed.y.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 });
                                    }
                                    return label;
                                }
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                color: 'white',
                                font: {
                                    size: 12
                                }
                            }
                        }
                    },
                    elements: {
                        line: {
                            borderWidth: 2
                        },
                        bar: {
                            backgroundColor: 'rgba(255, 255, 255, 0.1)',
                            borderColor: 'rgba(255, 255, 255, 0.3)',
                            borderWidth: 1
                        }
                    }
                }
            });
            
            // Add Fibonacci retracement levels if active
            if (isPremiumUser && activeIndicators.includes('fib') && prices.length > 0) {
                const fibLevels = calculateFibonacciRetracement(prices.map(p => p.y));
                const lastDate = historicalData[historicalData.length - 1].x;
                
                // Create annotation for each Fibonacci level
                const annotations = {};
                Object.entries(fibLevels).forEach(([level, value]) => {
                    const levelNum = level.replace('level', '');
                    annotations[level] = {
                        type: 'line',
                        yMin: value,
                        yMax: value,
                        borderColor: levelNum === '0' || levelNum === '100' ? 'rgba(255, 0, 0, 0.7)' : 'rgba(0, 255, 0, 0.7)',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        label: {
                            content: `Fib ${levelNum}%`,
                            enabled: true,
                            position: 'right',
                            backgroundColor: 'rgba(0, 0, 0, 0.7)'
                        }
                    };
                });
                
                // Update chart with annotations
                priceChart.options.plugins.annotation = {
                    annotations: annotations
                };
                priceChart.update();
            }
        }
        
        // Generate advanced predictions using multiple indicators
        function generateAdvancedPredictions(currentPrice, historicalPrices, historicalVolumes) {
            const predictions = [];
            const today = new Date();
            
            // Extract price and volume data
            const prices = historicalPrices.map(p => p[1]);
            const volumes = historicalVolumes.map(v => v[1]);
            
            // Calculate all indicators
            const ema20 = calculateEMA(prices, 20);
            const ema50 = calculateEMA(prices, 50);
            const ema200 = calculateEMA(prices, 200);
            const vwma = calculateVWMA(prices, volumes, 20);
            const rsi = calculateRSI(prices);
            const macd = calculateMACD(prices);
            const bollinger = calculateBollingerBands(prices);
            const fib = calculateFibonacciRetracement(prices);
            
            // Calculate volatility (standard deviation of logarithmic returns)
            const logReturns = [];
            for (let i = 1; i < prices.length; i++) {
                logReturns.push(Math.log(prices[i] / prices[i - 1]));
            }
            const volatility = Math.sqrt(logReturns.reduce((sum, val) => sum + Math.pow(val, 2), 0) / logReturns.length) * Math.sqrt(365);
            
            // Calculate momentum (slope of linear regression over last 14 days)
            let momentum = 0;
            if (prices.length >= 14) {
                const last14Prices = prices.slice(-14);
                const n = last14Prices.length;
                const xSum = n * (n - 1) / 2;
                const x2Sum = n * (n - 1) * (2 * n - 1) / 6;
                const ySum = last14Prices.reduce((sum, val) => sum + val, 0);
                const xySum = last14Prices.reduce((sum, val, i) => sum + val * i, 0);
                
                const slope = (n * xySum - xSum * ySum) / (n * x2Sum - xSum * xSum);
                momentum = slope / last14Prices[0] * 100; // as percentage
            }
            
            // Generate predictions for next 30 days
            for (let i = 1; i <= 30; i++) {
                const predictionDate = new Date(today);
                predictionDate.setDate(today.getDate() + i);
                
                // Base price movement based on momentum and volatility
                let priceMovement = momentum * 0.5 + (Math.random() - 0.5) * volatility * 0.8;
                
                // Adjust based on RSI
                const lastRSI = rsi[rsi.length - 1];
                if (lastRSI < 30) {
                    priceMovement += 0.5; // Oversold - expect bounce
                } else if (lastRSI > 70) {
                    priceMovement -= 0.5; // Overbought - expect pullback
                }
                
                // Adjust based on MACD
                const lastMACD = macd.macdLine[macd.macdLine.length - 1];
                const lastSignal = macd.signalLine[macd.signalLine.length - 1];
                if (lastMACD > lastSignal) {
                    priceMovement += 0.3; // Bullish crossover
                } else if (lastMACD < lastSignal) {
                    priceMovement -= 0.3; // Bearish crossover
                }
                
                // Adjust based on Bollinger Bands position
                const lastPrice = prices[prices.length - 1];
                const lastUpper = bollinger.upper[bollinger.upper.length - 1];
                const lastLower = bollinger.lower[bollinger.lower.length - 1];
                if (lastPrice > lastUpper) {
                    priceMovement -= 0.4; // Above upper band - expect reversion
                } else if (lastPrice < lastLower) {
                    priceMovement += 0.4; // Below lower band - expect bounce
                }
                
                // Adjust based on Fibonacci levels
                if (lastPrice < fib.level38 && lastPrice > fib.level50) {
                    priceMovement += 0.2; // Between 38.2% and 50% - support zone
                } else if (lastPrice < fib.level50 && lastPrice > fib.level61) {
                    priceMovement += 0.3; // Between 50% and 61.8% - strong support
                } else if (lastPrice > fib.level38 && lastPrice < fib.level23) {
                    priceMovement -= 0.2; // Between 23.6% and 38.2% - resistance zone
                }
                
                // Calculate predicted price
                const lastPriceForPrediction = i === 1 ? currentPrice : predictions[i-2].price;
                const price = lastPriceForPrediction * (1 + priceMovement / 100);
                
                // Calculate change from current price
                const change = ((price - currentPrice) / currentPrice) * 100;
                
                // Confidence calculation
                let confidence = 90 - (i * 2); // Base confidence decreases with time
                
                // Increase confidence if multiple indicators agree
                const bullishIndicators = [
                    lastRSI < 30,
                    lastMACD > lastSignal,
                    lastPrice < lastLower,
                    momentum > 0,
                    ema20[ema20.length - 1] > ema50[ema50.length - 1]
                ].filter(Boolean).length;
                
                const bearishIndicators = [
                    lastRSI > 70,
                    lastMACD < lastSignal,
                    lastPrice > lastUpper,
                    momentum < 0,
                    ema20[ema20.length - 1] < ema50[ema50.length - 1]
                ].filter(Boolean).length;
                
                if (priceMovement > 0 && bullishIndicators >= 3) {
                    confidence += 5;
                } else if (priceMovement < 0 && bearishIndicators >= 3) {
                    confidence += 5;
                }
                
                // Add some randomness to confidence
                confidence += (Math.random() * 10 - 5);
                
                // Ensure confidence is within bounds
                confidence = Math.min(95, Math.max(65, Math.round(confidence)));
                
                predictions.push({
                    date: predictionDate.toISOString(),
                    price: price,
                    change: change,
                    confidence: confidence
                });
            }
            
            return predictions;
        }
        
        // AI Assistant Functions
        function toggleAssistant() {
            assistantModal.classList.toggle('active');
            assistantActive = !assistantActive;
            
            if (assistantActive) {
                assistantButton.innerHTML = '<i class="fas fa-times"></i>';
                assistantButton.style.transform = 'rotate(180deg)';
            } else {
                assistantButton.innerHTML = '<i class="fas fa-robot"></i>';
                assistantButton.style.transform = 'rotate(0deg)';
            }
        }
        
        function sendAssistantMessage() {
            const message = assistantInput.value.trim();
            if (message === '') return;
            
            // Add user message to chat
            addMessageToAssistant('user', message);
            assistantInput.value = '';
            
            // Simulate AI response after a short delay
            setTimeout(() => {
                const response = generateAssistantResponse(message);
                addMessageToAssistant('bot', response);
            }, 500);
        }
        
        function addMessageToAssistant(sender, text) {
            const messageElement = document.createElement('div');
            messageElement.className = `assistant-message ${sender}`;
            messageElement.textContent = text;
            assistantMessages.appendChild(messageElement);
            assistantMessages.scrollTop = assistantMessages.scrollHeight;
        }
        
        function generateAssistantResponse(message) {
            const lowerMessage = message.toLowerCase();
            
            if (lowerMessage.includes('help') || lowerMessage.includes('assist')) {
                return "I can help explain predictions, analyze market trends, or simplify complex crypto concepts. What would you like to know?";
            } else if (lowerMessage.includes('prediction') || lowerMessage.includes('forecast')) {
                return "Our predictions combine technical indicators, market sentiment, and on-chain data. The confidence percentage shows how reliable each forecast is.";
            } else if (lowerMessage.includes('simple') || lowerMessage.includes('explain like i\'m 5')) {
                return "Imagine crypto prices are like a seesaw. When more people want to buy than sell, the price goes up. Our AI tries to guess which way the seesaw will tilt next!";
            } else if (lowerMessage.includes('buy') || lowerMessage.includes('sell')) {
                return "Our suggestions are based on multiple factors. Green 'Buy' means the AI sees potential growth, while red 'Sell' suggests it might be a good time to take profits.";
            } else if (lowerMessage.includes('weather') || lowerMessage.includes('climate')) {
                return "The Crypto Weather Report gives a quick snapshot of market conditions. Sunny means good times ahead, while stormy suggests volatility coming.";
            } else if (lowerMessage.includes('bingo') || lowerMessage.includes('game')) {
                return "The Prediction Bingo is a fun way to track market events. Mark squares when predictions come true to complete lines and earn rewards!";
            } else if (lowerMessage.includes('tarot') || lowerMessage.includes('fortune')) {
                return "The Crypto Tarot is a playful way to get alternative market insights. While not serious analysis, it can sometimes highlight important trends.";
            } else {
                // Default responses
                const responses = [
                    "Interesting question! Our AI analyzes multiple data points to generate predictions with high accuracy.",
                    "I can help explain that. The key factors we consider are price trends, trading volume, and market sentiment.",
                    "Great point! Would you like me to simplify this concept or provide more technical details?",
                    "Our system shows both short-term and long-term predictions to help with different trading strategies.",
                    "That's a common question. The colored indicators show whether the market is trending up (green) or down (red)."
                ];
                return responses[Math.floor(Math.random() * responses.length)];
            }
        }
        
        function toggleVoiceRecognition() {
            if (!('webkitSpeechRecognition' in window)) {
                addMessageToAssistant('bot', "Sorry, voice commands aren't supported in your browser.");
                return;
            }
            
            const recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            
            recognition.onstart = function() {
                voiceButton.innerHTML = '<i class="fas fa-microphone-slash"></i>';
            };
            
            recognition.onresult = function(event) {
                const transcript = event.results[0][0].transcript;
                assistantInput.value = transcript;
                voiceButton.innerHTML = '<i class="fas fa-microphone"></i>';
                sendAssistantMessage();
            };
            
            recognition.onerror = function(event) {
                voiceButton.innerHTML = '<i class="fas fa-microphone"></i>';
                addMessageToAssistant('bot', "Sorry, I didn't catch that. Please try again.");
            };
            
            recognition.start();
        }
        
        // Gamification Features
        function initializeBingoCard() {
            const bingoTerms = [
                "BTC hits new ATH",
                "Market correction >10%",
                "Meme coin goes viral",
                "Major exchange hack",
                "Regulation news",
                "Whale movement",
                "Fed rate change",
                "ETH gas fees spike",
                "NFT sales boom",
                "DeFi TVL drops",
                "Celebrity endorsement",
                "Bear market rally",
                "Stablecoin depeg",
                "Layer 2 adoption",
                "CBDC announcement",
                "Mining difficulty up",
                "Exchange outage",
                "SEC lawsuit",
                "Inflation data",
                "Institutional inflow",
                "DAO proposal passes",
                "Bridge exploit",
                "Staking rewards cut",
                "FOMO buying spree",
                "FUD spreads"
            ];
            
            // Shuffle and select 24 terms (plus free center)
            const shuffled = bingoTerms.sort(() => 0.5 - Math.random());
            bingoCard = shuffled.slice(0, 24);
            
            // Add free center space
            bingoCard.splice(12, 0, "FREE SPACE");
            
            // Generate HTML
            generateBingoCardHTML();
        }
        
        function generateBingoCardHTML() {
            let html = '';
            for (let i = 0; i < 25; i++) {
                const isMarked = markedBingoSquares.includes(i);
                const isCenter = i === 12;
                html += `
                    <div class="bingo-square ${isMarked ? 'marked' : ''} ${isCenter ? 'bingo-center' : ''}" 
                         data-index="${i}">
                        ${isCenter ? '<i class="fas fa-star"></i>' : bingoCard[i]}
                    </div>
                `;
            }
            return html;
        }
        
        function updateBingoProgress() {
            const progress = (markedBingoSquares.length / 25) * 100;
            bingoProgressBar.style.width = `${progress}%`;
            
            // Check for bingo (simple version - just count marked squares)
            if (markedBingoSquares.length >= 5) {
                addMessageToAssistant('bot', "🎉 You've marked 5 squares on your bingo card! Keep watching the market for more opportunities.");
            }
        }
        
        function generateCryptoWeather() {
            const weatherTypes = [
                { icon: 'fa-sun', desc: "Sunny with clear skies - perfect conditions for altcoin growth!" },
                { icon: 'fa-cloud-sun', desc: "Partly cloudy - some volatility expected but overall positive trends" },
                { icon: 'fa-cloud', desc: "Cloudy with a chance of showers - sideways movement likely" },
                { icon: 'fa-cloud-rain', desc: "Rainy conditions - prepare for potential market dips" },
                { icon: 'fa-bolt', desc: "Thunderstorm warning - high volatility and possible flash crashes" },
                { icon: 'fa-snowflake', desc: "Winter chill - bearish sentiment may freeze trading volume" },
                { icon: 'fa-wind', desc: "Windy conditions - rapid price changes in both directions" },
                { icon: 'fa-meteor', desc: "Meteor shower - extreme market conditions expected" }
            ];
            
            const weather = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
            return `<i class="fas ${weather.icon}"></i> ${weather.desc}`;
        }
        
        function generateRealityCheck() {
            const checks = [
                "Our AI detects you might be experiencing confirmation bias - consider alternative viewpoints before trading.",
                "Analysis suggests you're making rational decisions based on data, not emotions. Well done!",
                "The system notes you tend to favor short-term trades. Remember to consider long-term trends as well.",
                "Our algorithms detect potential overconfidence in recent predictions. Always use stop-losses.",
                "You're showing good discipline by sticking to your trading plan. Keep it up!",
                "The AI suggests you might be reacting to recent losses. Remember - one trade doesn't define your strategy."
            ];
            
            return checks[Math.floor(Math.random() * checks.length)];
        }
        
        function drawTarotCard() {
            const cards = [
                { 
                    name: "The Bull", 
                    image: '<i class="fas fa-bullhorn"></i>',
                    meaning: "A strong upward trend is coming. Look for buying opportunities in fundamentally sound projects."
                },
                { 
                    name: "The Bear", 
                    image: '<i class="fas fa-paw"></i>',
                    meaning: "Caution is advised. The market may be entering a downturn. Consider taking profits or hedging."
                },
                { 
                    name: "The Whale", 
                    image: '<i class="fas fa-fish"></i>',
                    meaning: "Big players are moving in the market. Watch for unusual activity that could signal major moves."
                },
                { 
                    name: "The HODLer", 
                    image: '<i class="fas fa-hand-holding"></i>',
                    meaning: "Patience will be rewarded. The best strategy may be to hold through short-term volatility."
                },
                { 
                    name: "The Moon", 
                    image: '<i class="fas fa-moon"></i>',
                    meaning: "Extreme gains are possible, but beware of irrational exuberance. Don't chase pumps."
                },
                { 
                    name: "The Reaper", 
                    image: '<i class="fas fa-skull"></i>',
                    meaning: "A market cleansing may be coming. Weak projects could fail while strong ones survive."
                }
            ];
            
            const card = cards[Math.floor(Math.random() * cards.length)];
            return {
                image: card.image,
                meaning: `<strong>${card.name}</strong>: ${card.meaning}`
            };
        }
        
        function analyzeMemeImpact() {
            const score = Math.floor(Math.random() * 100);
            let impact;
            
            if (score > 75) {
                impact = "Highly positive meme sentiment detected. Viral trends could drive prices up short-term.";
            } else if (score > 50) {
                impact = "Moderate meme activity. Some coins may see temporary boosts from social media hype.";
            } else if (score > 25) {
                impact = "Low meme impact. Fundamentals are driving the market more than social trends.";
            } else {
                impact = "Negative meme sentiment detected. FUD could create buying opportunities if overdone.";
            }
            
            return {
                score: score,
                impact: impact
            };
        }
    </script>
</body>
</html>